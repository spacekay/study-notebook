---
description: Day 1 Application Security
---

# Day 1 Application Security

### Authentication (인증)

* 통신 상에서 보내는 사람의 디지털 정체성을 확인하기 위한 시도의 과정 -> **로그인**, 신분증 제시 등
  * 유효한 사용자인지 증명하는 것
* 온라인에서는 Username, password, OTP 등 인증 시스템 활용
* Session (세션)
  * 사용자 인증 결과를 유지 -> 세션이 유지되는 동안에는 신분 확인 절차를 반복하지 않음 -> **Stateful**
* Stateless하게 사용자 인증을 진행하고자 하는 경우에는 HTTP 등을 사용

### Authorization (인가)

* 인증 -> 증명, 인가 -> 허가
  * 관리자인지 증명함 -> 인증
  * 관리 메뉴를 접속할 수 있게 함 -> 인가
* 사용자 - 클라이언트 - 서버
  * 사용자 : 로그인 페이지로 인증 후, 접근이 거부될 때마다 인가 과정 확인
  * 클라이언트 : 로그인 과정에서 토큰 등을 얻고(인증), 매 요청마다 쿠키 등을 통해 관리하여 서버로 토큰 전달하여 인가 과정 진행
  * 서버 : 모든 요청에 대해 인증 작업 수행
    * 인증 : 로그인 요청 확인하여 토큰 발행 & 토큰 검증하여 사용자가 누구인지 확인
    * 인가 : 해당 사용자가 올바른 접근을 했는지 확인 -> 요청 허용 또는 금지
  * Spring Web MVC -> Controller 도착 전 요청을 **HandlerIntercepter**를 통해 인증 및 인가
  * Spring Security -> **SecurityFilterChain**(Servlet 진입 이전 Filter 단계)을 통해 인증 및 인가

### Encrytion (암호화)

* 평문(원래 값)을 알기 어렵도록 변환하여 암호문을 만드는 작업
  * 암호문을 다시 평문으로 바꾸는 작업 -> 복호화
  * 복호화할 수 있는 암호문 : 양방향
  * 복호화할 수 없는 암호문 : 단방향 (비가역적)
* 사용자 암호 -> 복호화할 수 없는 방식으로 DB 등에 저장
  * 인증 : 사용자가 입력한 암호를 암호화하여 이미 암호화된 값과 비교하여 입력을 검증
* 단방향 암호화 -> 암호학적 해시 알고리즘 사용
  * 암호학적 해시 알고리즘의 성질
    1. **역상 저항성** : 해시 값(암호문)에서 원래의 값(평문)을 찾을 수 없어야 함
    2. **제2 역상 저항성** : 원래 값과 다르지만 동일한 해시 값으로 변환되는 다른 값을 찾을 수 없어야 함
    3. **충돌 저항성** : 동일한 해시 값으로 변환되는 두개의 값을 찾을 수 없어야 함
       * 암호문과 원문은 1대 1로만 대응해야 함
  * 해시 함수가 암호학적 해시 알고리즘인지 여부를 위의 세 가지를 통해 검증 가능

#### 단방향암호화 구현 방식

* 기존 : bcrypt, scrypt
* 최근 : Argon2 (Spring Security 지원), Balloon
